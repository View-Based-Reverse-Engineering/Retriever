package eu.qimpress.reverseengineering.gast2seff.visitors;

 import java.util.ArrayList;
import java.util.BitSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Logger;
import org.eclipse.gmt.modisco.java.ASTNode;
import org.eclipse.gmt.modisco.java.AbstractMethodInvocation;
import org.eclipse.gmt.modisco.java.AssertStatement;
import org.eclipse.gmt.modisco.java.Block;
import org.eclipse.gmt.modisco.java.BreakStatement;
import org.eclipse.gmt.modisco.java.EnhancedForStatement;
import org.eclipse.gmt.modisco.java.ExpressionStatement;
import org.eclipse.gmt.modisco.java.ForStatement;
import org.eclipse.gmt.modisco.java.IfStatement;
import org.eclipse.gmt.modisco.java.Statement;
import org.eclipse.gmt.modisco.java.SwitchCase;
import org.eclipse.gmt.modisco.java.SwitchStatement;
import org.eclipse.gmt.modisco.java.TryStatement;
import org.eclipse.gmt.modisco.java.VariableDeclarationStatement;
import org.eclipse.gmt.modisco.java.WhileStatement;
import org.eclipse.gmt.modisco.java.emf.JavaFactory;
import org.eclipse.gmt.modisco.java.emf.util.JavaSwitch;
import org.eclipse.gmt.modisco.omg.kdm.source.SourceRegion;
import org.eclipse.modisco.java.composition.javaapplication.JavaNodeSourceRegion;

//import de.fzi.gast.accesses.Access;//GAST2SEFFCHANGE
//import de.fzi.gast.accesses.BaseAccess;//GAST2SEFFCHANGE
//import de.fzi.gast.accesses.FunctionAccess;//GAST2SEFFCHANGE
//import de.fzi.gast.core.Position;//GAST2SEFFCHANGE
//import de.fzi.gast.statements.BlockStatement;//GAST2SEFFCHANGE
//import de.fzi.gast.statements.Branch;//GAST2SEFFCHANGE
//import de.fzi.gast.statements.BranchStatement;//GAST2SEFFCHANGE
//import de.fzi.gast.statements.LoopStatement;//GAST2SEFFCHANGE
//import de.fzi.gast.statements.SimpleStatement;//GAST2SEFFCHANGE
//import de.fzi.gast.statements.Statement;//GAST2SEFFCHANGE
//import de.fzi.gast.statements.util.statementsSwitch;//GAST2SEFFCHANGE
import eu.qimpress.reverseengineering.gast2seff.jobs.GAST2SEFFJob;
import eu.qimpress.reverseengineering.gast2seff.visitors.FunctionCallClassificationVisitor.FunctionCallType;
import eu.qimpress.samm.staticstructure.InterfacePort;
import eu.qimpress.samm.staticstructure.Operation;
import eu.qimpress.samm.staticstructure.PrimitiveComponent;
import eu.qimpress.seff.AbstractBranchTransition;
import eu.qimpress.seff.BranchAction;
import eu.qimpress.seff.ExternalCallAction;
import eu.qimpress.seff.InternalAction;
import eu.qimpress.seff.LoopAction;
import eu.qimpress.seff.ResourceDemandingBehaviour;
import eu.qimpress.seff.seffFactory;

import org.somox.kdmhelper.GetAccessedType;
import org.somox.kdmhelper.KDMHelper;
import org.somox.sourcecodedecorator.InterfaceSourceCodeLink;
import org.somox.sourcecodedecorator.MethodLevelSourceCodeLink;
import org.somox.sourcecodedecorator.SourceCodeDecoratorRepository;

/**
 * A visitor which traverses a GAST behaviour and creates a SEFF matching the traversed behaviour. The 
 * generated SEFF is abstracted based on a classification of the GAST statements into external and
 * internal service calls.
 * <br>
 * <code>functionClassificationAnnotation</code> classifies which elements to hold when traversing the
 * GAST behaviour.
 * 
 * @author Steffen Becker, Klaus Krogmann
 */
public class GastStatementVisitor 
extends JavaSwitch<Object> {//GAST2SEFFCHANGE

	private static final Logger logger = Logger.getLogger(GastStatementVisitor.class);
	
	/**
	 * The RD-Behaviour to generate
	 */
	private ResourceDemandingBehaviour seff;
	
	/**
	 * Mapping to SAMM repository (for external call lookup)
	 */
	private SourceCodeDecoratorRepository sourceCodeDecoratorRepository;
	
	/**
	 * The component the created SEFF belongs to.
	 */
	private PrimitiveComponent primitiveComponent;
	
	/**
	 * Map which contains for each statement in the GAST model the type of the statement 
	 * classified according to {@link FunctionCallType}. Nodes of control flow constructs
	 * like loops and branches carry the union of the annotations of their child statements
	 */
	private Map<Statement, BitSet> functionClassificationAnnotation;

	/**
	 * Classification annotation of the last visited statement. Used to skip generating
	 * SEFF actions if they should be omitted because of the SEFFs abstraction rule 
	 */
	private BitSet lastType = null;
	
	/**
	 * Constructor
	 * @param functionClassificationAnnotations A map containing the type annotations for the
	 * nodes of the GAST model. Generated by a {@link FunctionCallClassificationVisitor}.
	 * @param resourceDemandingBehaviour The RD-behaviour to generate
	 * @param gastBehaviourRepository The gast behaviour which maps gast statements and SAMM repository.
	 * @param primitiveComponent 
	 */
	public GastStatementVisitor(Map<Statement,BitSet> functionClassificationAnnotations,
			ResourceDemandingBehaviour resourceDemandingBehaviour, 
			SourceCodeDecoratorRepository gastBehaviourRepository, 
			PrimitiveComponent primitiveComponent) {
		super();
		
		this.seff = resourceDemandingBehaviour;
		this.functionClassificationAnnotation = functionClassificationAnnotations;
		this.sourceCodeDecoratorRepository = gastBehaviourRepository;
		this.primitiveComponent = primitiveComponent;
	}

	@Override
	public Object caseBlock(Block object) {//GAST2SEFFCHANGE//GAST2SEFFCHANGE
		for (Statement s : object.getStatements()) {
			BitSet thisType = this.functionClassificationAnnotation.get(s);
			if (!shouldSkip(lastType,thisType)) { // Only generate elements for statements which should not be abstracted away
				// avoid infinite recursion
				if(!isVisitedStatement(thisType)) {
					setVisited(thisType);
					doSwitch(s);
				}
			}
			lastType = thisType;
		}		
		return null;
	}

	
//	@Override
//	public Object caseBranchStatement(BranchStatement object) {
//		if (containsExternalCall(object)) {
//			BranchAction branch = seffFactory.eINSTANCE.createBranchAction();
//			seff.getSteps().add(branch);
//			branch.setName(positionToString(object.getPosition()));
//			branch.setDocumentation(blockToString(object.getBlockstatement()));			
//			
//			for (Branch b : object.getBranches()) {
//				AbstractBranchTransition bt = seffFactory.eINSTANCE.createProbabilisticBranchTransition();
//				bt.setResourceDemandingBehaviour(seffFactory.eINSTANCE.createResourceDemandingBehaviour());
//				bt.getResourceDemandingBehaviour().getSteps().add(seffFactory.eINSTANCE.createStartAction());				
//				bt.setName("parent " + positionToString(object.getPosition()) + "/" + positionToString(b.getPosition())); //use parent position since branch position is empty
//				branch.getAbstractBranchTransition().add(bt);
//				GastStatementVisitor visitor = new GastStatementVisitor(this.functionClassificationAnnotation,
//						bt.getResourceDemandingBehaviour(), this.sourceCodeDecoratorRepository, this.primitiveComponent);
//				Statement s = b.getStatement();
//				visitor.doSwitch(s);				
//				bt.getResourceDemandingBehaviour().getSteps().add(seffFactory.eINSTANCE.createStopAction());
//				GAST2SEFFJob.connectActions(bt.getResourceDemandingBehaviour());
//			}
//		} else {
//			createInternalAction(object);
//		}
//		return null;
//	}

	@Override
	public Object caseIfStatement(IfStatement object) {
		if (containsExternalCall(object)) {
			BranchAction branch = seffFactory.eINSTANCE.createBranchAction();
			seff.getSteps().add(branch);
			branch.setName(positionToString(KDMHelper.getJavaNodeSourceRegion(object)));//GAST2SEFFCHANGE
			//TODO ??????
//			branch.setDocumentation(blockToString(object.getBlockstatement()));			
			branch.setDocumentation("not yet adapted");
			
			//TODO refactor this, duplicated code
			{
			Statement ifStatement = object.getThenStatement();
			AbstractBranchTransition bt = seffFactory.eINSTANCE.createProbabilisticBranchTransition();
			bt.setResourceDemandingBehaviour(seffFactory.eINSTANCE.createResourceDemandingBehaviour());
			bt.getResourceDemandingBehaviour().getSteps().add(seffFactory.eINSTANCE.createStartAction());				
			bt.setName("parent " + positionToString(KDMHelper.getJavaNodeSourceRegion(object)) + "/" + positionToString(KDMHelper.getJavaNodeSourceRegion(ifStatement))); //use parent position since branch position is empty//GAST2SEFFCHANGE//GAST2SEFFCHANGE
			branch.getAbstractBranchTransition().add(bt);
			GastStatementVisitor visitor = new GastStatementVisitor(this.functionClassificationAnnotation,
					bt.getResourceDemandingBehaviour(), this.sourceCodeDecoratorRepository, this.primitiveComponent);
//			Statement s = b.getStatement();//GAST2SEFFCHANGE
			visitor.doSwitch(ifStatement);				
			bt.getResourceDemandingBehaviour().getSteps().add(seffFactory.eINSTANCE.createStopAction());
			GAST2SEFFJob.connectActions(bt.getResourceDemandingBehaviour());
			}

			{
			Statement elseStatement = object.getElseStatement();
			if(elseStatement != null){
				AbstractBranchTransition bt = seffFactory.eINSTANCE.createProbabilisticBranchTransition();
				bt.setResourceDemandingBehaviour(seffFactory.eINSTANCE.createResourceDemandingBehaviour());
				bt.getResourceDemandingBehaviour().getSteps().add(seffFactory.eINSTANCE.createStartAction());				
				bt.setName("parent " + positionToString(KDMHelper.getJavaNodeSourceRegion(object)) + "/" + positionToString(KDMHelper.getJavaNodeSourceRegion(elseStatement))); //use parent position since branch position is empty//GAST2SEFFCHANGE//GAST2SEFFCHANGE
				branch.getAbstractBranchTransition().add(bt);
				GastStatementVisitor visitor = new GastStatementVisitor(this.functionClassificationAnnotation,
						bt.getResourceDemandingBehaviour(), this.sourceCodeDecoratorRepository, this.primitiveComponent);
//			Statement s = b.getStatement();//GAST2SEFFCHANGE
				visitor.doSwitch(elseStatement);				
				bt.getResourceDemandingBehaviour().getSteps().add(seffFactory.eINSTANCE.createStopAction());
				GAST2SEFFJob.connectActions(bt.getResourceDemandingBehaviour());
			}
			}
		} else {
			createInternalAction(object);
		}
		return null;
	}

	//TODO replace this
	@Override
	public Object caseSwitchStatement(SwitchStatement switchStatement) {
		if (containsExternalCall(switchStatement)) {
			BranchAction branch = seffFactory.eINSTANCE.createBranchAction();
			seff.getSteps().add(branch);
//			branch.setName(positionToString(object.getPosition()));
//			branch.setDocumentation(blockToString(object.getBlockstatement()));			
			
			List<Block> blockList = new ArrayList<Block>();
			
			Iterator<Statement> iterator = switchStatement.getStatements().iterator();
			
			while(iterator.hasNext()){
				Statement statement = iterator.next();
				if(statement instanceof SwitchCase){
					Block block;
					block = JavaFactory.eINSTANCE.createBlock();
					while(true){
						Statement innerStatement = iterator.next();
						if(!(innerStatement instanceof BreakStatement)){
							block.getStatements().add(innerStatement);
						}
						else{
							break;
						}
					}
					blockList.add(block);
				}
			}
			
			for (Block b : blockList) {
				AbstractBranchTransition bt = seffFactory.eINSTANCE.createProbabilisticBranchTransition();
				bt.setResourceDemandingBehaviour(seffFactory.eINSTANCE.createResourceDemandingBehaviour());
				bt.getResourceDemandingBehaviour().getSteps().add(seffFactory.eINSTANCE.createStartAction());				
//TODO				bt.setName("parent " + positionToString(switchStatement.getPosition()) + "/" + positionToString(b.getPosition())); //use parent position since branch position is empty
				branch.getAbstractBranchTransition().add(bt);
				GastStatementVisitor visitor = new GastStatementVisitor(this.functionClassificationAnnotation,
						bt.getResourceDemandingBehaviour(), this.sourceCodeDecoratorRepository, this.primitiveComponent);
//				Statement s = b.getStatement();
				visitor.doSwitch(b);				
				bt.getResourceDemandingBehaviour().getSteps().add(seffFactory.eINSTANCE.createStopAction());
				GAST2SEFFJob.connectActions(bt.getResourceDemandingBehaviour());
			}
		} else {
			createInternalAction(switchStatement);
		}
		return null;
	}

//	@Override
//	public Object caseLoopStatement(LoopStatement object) {
//		if (containsExternalCall(object)) {
//			LoopAction loop = seffFactory.eINSTANCE.createLoopAction();
//			loop.setBodyBehaviour(seffFactory.eINSTANCE.createResourceDemandingBehaviour());
//			seff.getSteps().add(loop);
//			loop.getBodyBehaviour().getSteps().add(seffFactory.eINSTANCE.createStartAction());
//			loop.setName(positionToString(object.getPosition()));
//			loop.setDocumentation(blockToString(object.getBlockstatement()));
//
//			new GastStatementVisitor(this.functionClassificationAnnotation,
//					loop.getBodyBehaviour(), this.sourceCodeDecoratorRepository,
//					this.primitiveComponent).doSwitch(object.getBody());
//
//			loop.getBodyBehaviour().getSteps().add(seffFactory.eINSTANCE.createStopAction());
//			GAST2SEFFJob.connectActions(loop.getBodyBehaviour());
//		} else {
//			createInternalAction(object);
//		}
//		return null;
//	}
	
	@Override
	public Object caseEnhancedForStatement(EnhancedForStatement object) {
		if (containsExternalCall(object)) {
			LoopAction loop = seffFactory.eINSTANCE.createLoopAction();
			loop.setBodyBehaviour(seffFactory.eINSTANCE.createResourceDemandingBehaviour());
			seff.getSteps().add(loop);
			loop.getBodyBehaviour().getSteps().add(seffFactory.eINSTANCE.createStartAction());
			loop.setName(positionToString(KDMHelper.getJavaNodeSourceRegion(object)));//GAST2SEFFCHANGE
			//TODO
//			loop.setDocumentation(blockToString(object.getBlockstatement()));
			loop.setDocumentation("not yet implemented");

			new GastStatementVisitor(this.functionClassificationAnnotation,
					loop.getBodyBehaviour(), this.sourceCodeDecoratorRepository,
					this.primitiveComponent).doSwitch(object.getBody());

			loop.getBodyBehaviour().getSteps().add(seffFactory.eINSTANCE.createStopAction());
			GAST2SEFFJob.connectActions(loop.getBodyBehaviour());
		} else {
			createInternalAction(object);
		}
		return null;
	}

	@Override
	public Object caseForStatement(ForStatement object) {
		if (containsExternalCall(object)) {
			LoopAction loop = seffFactory.eINSTANCE.createLoopAction();
			loop.setBodyBehaviour(seffFactory.eINSTANCE.createResourceDemandingBehaviour());
			seff.getSteps().add(loop);
			loop.getBodyBehaviour().getSteps().add(seffFactory.eINSTANCE.createStartAction());
			loop.setName(positionToString(KDMHelper.getJavaNodeSourceRegion(object)));//GAST2SEFFCHANGE
			//TODO
//			loop.setDocumentation(blockToString(object.getBlockstatement()));
			loop.setDocumentation("not yet implemented");

			new GastStatementVisitor(this.functionClassificationAnnotation,
					loop.getBodyBehaviour(), this.sourceCodeDecoratorRepository,
					this.primitiveComponent).doSwitch(object.getBody());

			loop.getBodyBehaviour().getSteps().add(seffFactory.eINSTANCE.createStopAction());
			GAST2SEFFJob.connectActions(loop.getBodyBehaviour());
		} else {
			createInternalAction(object);
		}
		return null;
	}

	@Override
	public Object caseWhileStatement(WhileStatement object) {
		if (containsExternalCall(object)) {
			LoopAction loop = seffFactory.eINSTANCE.createLoopAction();
			loop.setBodyBehaviour(seffFactory.eINSTANCE.createResourceDemandingBehaviour());
			seff.getSteps().add(loop);
			loop.getBodyBehaviour().getSteps().add(seffFactory.eINSTANCE.createStartAction());
			loop.setName(positionToString(KDMHelper.getJavaNodeSourceRegion(object)));//GAST2SEFFCHANGE
			//TODO
//			loop.setDocumentation(blockToString(object.getBlockstatement()));
			loop.setDocumentation("not yet implemented");

			new GastStatementVisitor(this.functionClassificationAnnotation,
					loop.getBodyBehaviour(), this.sourceCodeDecoratorRepository,
					this.primitiveComponent).doSwitch(object.getBody());

			loop.getBodyBehaviour().getSteps().add(seffFactory.eINSTANCE.createStopAction());
			GAST2SEFFJob.connectActions(loop.getBodyBehaviour());
		} else {
			createInternalAction(object);
		}
		return null;
	}

	@Override
	public Object caseTryStatement(TryStatement object) {//GAST2SEFFCHANGE
		if (containsExternalCall(object)) {

			// visit guarded block
			new GastStatementVisitor(this.functionClassificationAnnotation,
					seff, this.sourceCodeDecoratorRepository,
					this.primitiveComponent).doSwitch(object.getBody());//GAST2SEFFCHANGE

			// visit finally block if exists 
			if(object.getFinally() != null) {//GAST2SEFFCHANGE
				new GastStatementVisitor(this.functionClassificationAnnotation,
					seff, this.sourceCodeDecoratorRepository,
					this.primitiveComponent).doSwitch(object.getFinally());//GAST2SEFFCHANGE
			}
			
		} else {
			createInternalAction(object);
		}
		return null;
	}	

//	@Override
//	public Object caseSimpleStatement(SimpleStatement object) {
//		BitSet statementAnnotation = this.functionClassificationAnnotation.get(object);
//		if (isExternalCall(statementAnnotation)) {
//			createExternalCallAction(object);
//		} else if (isInternalCall(statementAnnotation)) {
//			AbstractMethodInvocation functionAccess = getFunctionAccess(object);//GAST2SEFFCHANGE
//			Block body = functionAccess.getMethod().getBody();//GAST2SEFFCHANGE//GAST2SEFFCHANGE//GAST2SEFFCHANGE
//			if (body != null) {
//
//				// avoid infinite recursion
//				BitSet thisType = this.functionClassificationAnnotation.get(object);
//				if(!isVisitedStatement(thisType)) {
//					setVisited(thisType);
//					doSwitch(body);
//				}
//			} else {
//				String msg = "Behaviour not set in GAST for "+functionAccess.getMethod().getName();//GAST2SEFFCHANGE//GAST2SEFFCHANGE
//				if(KDMHelper.getJavaNodeSourceRegion(object) != null && KDMHelper.getSourceFile(KDMHelper.getJavaNodeSourceRegion(object)) != null && KDMHelper.computeFullQualifiedName(KDMHelper.getSourceFile(KDMHelper.getJavaNodeSourceRegion(object))) != null) {//GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE//
//					msg += ". Tried to call from " + KDMHelper.computeFullQualifiedName(KDMHelper.getSourceFile(KDMHelper.getJavaNodeSourceRegion(object))) + ".";//GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE//
//				} else {
//					msg += ". (caller position unknown)";
//				}
//				logger.warn(msg);
//			}
//		} else {
//			createInternalAction(object);
//		}
//		return null;
//	}

	@Override
	public Object caseAssertStatement(AssertStatement object) {
		return handleFormerSimpleStatement(object);
	}

	//TODO add path and name for "tried to call" line
	private Object handleFormerSimpleStatement(Statement object) {
		BitSet statementAnnotation = this.functionClassificationAnnotation.get(object);
		if (isExternalCall(statementAnnotation)) {
			createExternalCallAction(object);
		} else if (isInternalCall(statementAnnotation)) {
			AbstractMethodInvocation functionAccess = getFunctionAccess(object);//GAST2SEFFCHANGE
			Block body = functionAccess.getMethod().getBody();//GAST2SEFFCHANGE//GAST2SEFFCHANGE//GAST2SEFFCHANGE
			if (body != null) {

				// avoid infinite recursion
				BitSet thisType = this.functionClassificationAnnotation.get(object);
				if(!isVisitedStatement(thisType)) {
					setVisited(thisType);
					doSwitch(body);
				}
			} else {
				String msg = "Behaviour not set in GAST for "+functionAccess.getMethod().getName();//GAST2SEFFCHANGE//GAST2SEFFCHANGE
				if(KDMHelper.getJavaNodeSourceRegion(object) != null && KDMHelper.getSourceFile(KDMHelper.getJavaNodeSourceRegion(object)) != null && (KDMHelper.getSourceFile(KDMHelper.getJavaNodeSourceRegion(object))).getPath() != null) {//GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE//
					msg += ". Tried to call from " + (KDMHelper.getSourceFile(KDMHelper.getJavaNodeSourceRegion(object))).getPath() + ".";//GAST2SEFFCHANGE////GAST2SEFFCHANGE////GAST2SEFFCHANGE//
				} else {
					msg += ". (caller position unknown)";
				}
				logger.warn(msg);
			}
		} else {
			createInternalAction(object);
		}
		return null;
	}

	@Override
	public Object caseExpressionStatement(ExpressionStatement object) {
		return handleFormerSimpleStatement(object);	}

	@Override
	public Object caseVariableDeclarationStatement(
			VariableDeclarationStatement object) {
		return handleFormerSimpleStatement(object);	}

	/** Returns true if the statement with thisType should not generate an action in the newly generated SEFF
	 * @param lastType The type of the preceeding statement
	 * @param thisType The type of the statement to test
	 * @return true if the current statement should not generate an element in the SEFF, i.e., it should be abstracted and thrown away
	 */
	private boolean shouldSkip(BitSet lastType, BitSet thisType) {
		if (lastType == null)
			return false;
		
		if (isExternalCall(thisType))
			return false;
		
		// Here I know that thisType is internal or library
		// Hence, I can skip this if the last type was not an external call
		return !isExternalCall(lastType);
	}

	private void createExternalCallAction(Statement object) {//GAST2SEFFCHANGE
		ExternalCallAction call = seffFactory.eINSTANCE.createExternalCallAction();
		AbstractMethodInvocation access = getFunctionAccess(object);//GAST2SEFFCHANGE
		call.setName(access.getMethod().getName());//GAST2SEFFCHANGE//GAST2SEFFCHANGE
		InterfacePortOperationTuple ifOperationTuple = getCalledInterfacePort(access);	
		call.setCalledInterfacePort(ifOperationTuple.interfacePort);
		call.setCalledService(ifOperationTuple.operation);
		call.setDocumentation(positionToString(KDMHelper.getJavaNodeSourceRegion(object)));//GAST2SEFFCHANGE
		seff.getSteps().add(call);
	}

	/**
	 * Query the interface port for the function access using the source code decorator.
	 * @param access The access to find in the SAMM
	 * @return interface port and operation for corresponding to the access.
	 */
	private InterfacePortOperationTuple getCalledInterfacePort(AbstractMethodInvocation access) {//GAST2SEFFCHANGE
		InterfacePortOperationTuple interfacePortOperationTuple = new InterfacePortOperationTuple();
		
		for(InterfacePort ifPort : this.primitiveComponent.getRequired()) {			
			for(InterfaceSourceCodeLink ifLink : this.sourceCodeDecoratorRepository.getInterfaceSourceCodeLink()) {				
				if(ifPort.getInterfaceType().equals(ifLink.getInterface())) {
					if(ifLink.getGastClass().equals(GetAccessedType.getAccessedType(access))) {//GAST2SEFFCHANGE
						
						logger.trace("accessed interface port " + ifPort.getName());
						interfacePortOperationTuple.interfacePort = ifPort;		
						//query operation:
						interfacePortOperationTuple.operation = queryInterfaceOperation(access);
						
						return interfacePortOperationTuple;
					}
				}
			}
		}
		
		logger.warn("found no if port for " + GetAccessedType.getAccessedType(access).getName());//GAST2SEFFCHANGE//GAST2SEFFCHANGE
		
		return interfacePortOperationTuple;
	}

	/**
	 * Interface operation query
	 * @param access The access to find in the SAMM
	 * @return Operation corresponding to function access
	 */
	private Operation queryInterfaceOperation(AbstractMethodInvocation access) {//GAST2SEFFCHANGE					
		for(MethodLevelSourceCodeLink methodLink : this.sourceCodeDecoratorRepository.getMethodLevelSourceCodeLink()) {
			
			if(methodLink.getFunction().equals(access.getMethod())) {//GAST2SEFFCHANGE
														
				logger.trace("accessed operation " + methodLink.getOperation().getName());				
				return methodLink.getOperation();  									
			}
		}
		
		logger.warn("no accessed operation found for " + access.getMethod().getName());//GAST2SEFFCHANGE//GAST2SEFFCHANGE			
		return null;
	}

	private boolean isExternalCall(BitSet statementAnnotation) {
		return statementAnnotation.get(FunctionCallClassificationVisitor.getIndex(FunctionCallType.EXTERNAL));
	}

	private boolean isInternalCall(BitSet statementAnnotation) {
		return statementAnnotation.get(FunctionCallClassificationVisitor.getIndex(FunctionCallType.INTERNAL));
	}
	
	private boolean isVisitedStatement(BitSet statementAnnotation) {
		return statementAnnotation.get(FunctionCallClassificationVisitor.getIndex(FunctionCallType.VISITED));
	}	
	
	private void setVisited(BitSet thisType) {
		thisType.set(FunctionCallClassificationVisitor.getIndex(
				FunctionCallType.VISITED), true);

	}

	private AbstractMethodInvocation getFunctionAccess(Statement object) {//GAST2SEFFCHANGE//GAST2SEFFCHANGE
		for (ASTNode a : KDMHelper.getAllAccesses(object)) {//GAST2SEFFCHANGE//GAST2SEFFCHANGE
			if (a instanceof AbstractMethodInvocation) {//GAST2SEFFCHANGE
				return (AbstractMethodInvocation) a;//GAST2SEFFCHANGE
			}
		}
		return null;
	}

	private void createInternalAction(Statement statement) {
		InternalAction ia = seffFactory.eINSTANCE.createInternalAction();
		
		ia.setName("IA " + positionToString(KDMHelper.getJavaNodeSourceRegion(statement)));//GAST2SEFFCHANGE
		//TODO
		if(statement instanceof Block){//GAST2SEFFADDED
			ia.setDocumentation(blockToString((Block) statement) + "; Statement SISSyID: " + KDMHelper.getSISSyID(statement));//GAST2SEFFCHANGE
		}else{//GAST2SEFFADDED
			ia.setDocumentation("not a block" + "; Statement SISSyID: " + KDMHelper.getSISSyID(statement));//GAST2SEFFCHANGE//GAST2SEFFADDED			
		}//GAST2SEFFADDED
		seff.getSteps().add(ia);
	}
	
	private String blockToString(Block blockstatement) {//GAST2SEFFCHANGE
		if(blockstatement != null) {
			StringBuilder blockString = new StringBuilder("Block: ");
			blockString.append(blockstatement.toString());
			if( KDMHelper.getAllAccesses(blockstatement) != null &&  //GAST2SEFFCHANGE
					KDMHelper.getAllAccesses(blockstatement).size() >= 1//GAST2SEFFCHANGE
					) {
				     ASTNode firstAccess = KDMHelper.getAllAccesses(blockstatement).get(0);//GAST2SEFFCHANGE//GAST2SEFFCHANGE
				     if (firstAccess instanceof ASTNode) {//GAST2SEFFCHANGE
				    	 ASTNode access = (ASTNode)firstAccess;//GAST2SEFFCHANGE//GAST2SEFFCHANGE
				    	 
				    	 if (GetAccessedType.getAccessedType(access) != null) {//GAST2SEFFCHANGE
				    		 blockString.append(" " + GetAccessedType.getAccessedType(access).getName() + "...");//GAST2SEFFCHANGE//GAST2SEFFCHANGE				    		 
				    	 }
				     }
			}
			return blockString.toString();
		} else {
			return "No blockstatement";
		}
	}
	
	private String positionToString(JavaNodeSourceRegion position) {//GAST2SEFFCHANGE
		StringBuilder positionString = new StringBuilder("position: ");
		if(position != null) {
			if(KDMHelper.getSourceFile(position) != null && KDMHelper.getSourceFile(position).getClass() != null) {//GAST2SEFFCHANGE//GAST2SEFFCHANGE
				//TODO change name of class
//				positionString.append(KDMHelper.getSourceFile(position).getPath() + KDMHelper.getSourceFile(position).getName());//GAST2SEFFCHANGE
				positionString.append(KDMHelper.computeFullQualifiedName(position.getJavaNode()) );//GAST2SEFFCHANGE
			}			
			positionString.append(" from " + position.getStartLine());
			positionString.append(" to " + position.getEndLine());
		} else {			
			positionString.append("no position information available");
		}
		return positionString.toString();
	}

	/**
	 * Returns true if the statement or one of its child statements (e.g., for loops or branches) is an external service call
	 * @param object The statement to check
	 * @return true if the statement or one of its child statements is an external service call
	 */
	private boolean containsExternalCall(Statement object) {
		return this.functionClassificationAnnotation.get(object).get(FunctionCallClassificationVisitor.getIndex(FunctionCallType.EXTERNAL));
	}
	
	private class InterfacePortOperationTuple {
		public InterfacePort interfacePort;
		public Operation operation;
	}

}


